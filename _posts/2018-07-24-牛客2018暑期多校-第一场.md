---
layout: post
title: 牛客2018暑期多校 第一场
date: 2018-07-24 15:17:01 +0800
categories: contest
tags: 组合数学 线性代数 DP 数据结构 斜率优化
img: https://vexoben.github.io/assets/images/Blog/2018-07-24-牛客2018暑期多校-第一场.JPG
---

牛客多校第一场的题解……补了三天才大概补得差不多了……感觉还是菜得不行啊

（刷新以获取数学公式）

## **A.Monotonic Matrix**

### **题意**

给定一个$$n*m$$的网格，在每个格子中填入$$0,1,2$$中的一个数。要求每行，每列填的数字非严格递增。输出方案数膜1e9+7。

多组数据，$$n,m<=1000$$，$$n$$总和不超过100000$$

## **题解**

很容易想到这就是两条分界线，一条是0与1的分界，一条是1和2的分界，都是从$$(0,n+1)$$到$$(m+1,0)$$，且前者不会跑到后者的下面。

直接DP的话复杂度是O(n^5)。

正解是运用Lindström–Gessel–Viennot lemma定理。

假设平面上有$$2n$$个不同的点，从其中的$$n$$个点出发走到另外$$n$$个点，令$$M$$等于：

![][1]:

其中$$e(a_i,b_j)$$是从$$a_i$$走到$$b_j$$的方案数，则路径不相交的方案数就是$$det(M)$$

所以我们把原来的模型转化一下，变成一条从$$(0,n+1)$$走到$$(m+1,0)$$，另一条从$$(1,n+2)$$走到$$(m+2,1)$$，两条不能相交的方案数。显然这就等于$$C(n+m,m)*C(n+m,m)-C(n+m,m-1)*C(n+m,n-1)$$

比赛的时候怎么推呢？果断oeis。

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int N=2005;
const int mod=1e9+7;

LL C[N][N];

int main() {
	C[0][0]=1;
	for (int i=1;i<N;i++) {
		C[i][0]=1;
		for (int j=1;j<=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
	}
	int n,m;
	while (~scanf("%d%d",&n,&m)) {
		LL ans=C[m+n][n]*C[m+n][n]-C[m+n][m-1]*C[m+n][n-1];
		ans%=mod; if (ans<0) ans+=mod;
		printf("%lld\n",ans);
	}
	return 0;
}
```

## **B.Symmetric Matrix**

### **题意**

求满足下述条件的$$n*n$$的矩阵$$A$$的个数，满足：

1、A_{i,j}=0，1，2

2、A_{i,i}=0；

3、每行和为2；

4、A=A^T

多组数据，$$n<=100000$$，$$n$$总和不超过$$1e7$$,答案膜$$m(m<=1e9)$$输出

### **题解**

首先要发现这描述的是一张无自环且每个点度数均为2的无向图的邻接矩阵。

于是问题转化为图的计数问题。

记$$dp[n]$$为$$n$$个点时的答案

下面考虑转移。有两种情况：

1、节点$$n$$和前面某个点连了两条边，有$$(n-1)*dp[n-2]$$种情况。

2、节点$$n$$和前面一些点形成了环。注意这是可以翻转的环排列，所以它的方案数是：

$$ \sum_{i=2}^{n-1}\dbinom{n-1}{i}*dp[n-i-1]*\frac{(i+1)!}{2(i+1)} $$

因此有：

$$ dp[n]=(n-1)*dp[n-2]+\sum_{i=2}^{n-1}\dbinom{n-1}{i}*dp[n-i-1]*\frac{(i+1)!}{2(i+1)} $$

拆掉组合数，

$$ dp[n]=(n-1)*dp[n-2]+\frac{(n-1)!}{2}*\sum_{i=2}^{n-1}\frac{dp[n-i-1]}{(n-i-1)!} $$

整理一下，

$$ dp[n]=(n-1)*dp[n-2]+\frac{(n-1)!}{2}*\sum_{i=1}^{n-3}\frac{dp[i]}{i!} $$

令$$dp[n]=(n-1)*dp[n-2]+g[n]$$，则

$$ g[n]=\frac{(n-1)!}{2}*\sum_{i=1}^{n-3}\frac{dp[i]}{i!} $$

联立:

$$ \frac{2*g[n]}{(n-2)!}=\sum_{i=1}^{n-3}\frac{dp[i]}{i!} $$

$$ \frac{2*g[n-1]}{(n-3)!}=\sum_{i=1}^{n-4}\frac{dp[i]}{i!} $$

相减并化简：

$$ g[n]=(n-1)*g[n-1]+\frac{(n-1)(n-2)}{2}*dp[n-3] $$

然后就可以$$O(n)$$递推了。

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int N=1e5+10;

int n,mod;
LL f[N],g[N];

void Solve() {
	f[0]=f[2]=1%mod;
	for (int i=3;i<=n;i++) {
		g[i]=1LL*(i-1)*g[i-1]%mod+1LL*(i-1)*(i-2)/2%mod*f[i-3]%mod;
		while (g[i]>=mod) g[i]-=mod;
		f[i]=(1LL*(i-1)*f[i-2]+g[i])%mod;
	}
	printf("%lld\n",f[n]);
}

int main() {
	while (~scanf("%d%d",&n,&mod)) Solve();
}
```

[1]:https://vexoben.github.io/assets/images/Blog/2018-07-24-牛客2018暑期多校-第一场(2).JPG